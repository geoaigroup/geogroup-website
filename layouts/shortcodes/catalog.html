<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"
    integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
    integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz"
    crossorigin="anonymous"></script>
<script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
<script src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-draw/v1.4.3/mapbox-gl-draw.js"></script>
<link rel="stylesheet" href="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-draw/v1.4.3/mapbox-gl-draw.css"
    type="text/css">


<hr>

<div class="d-flex justify-content-between flex-wrap" id="main_cards_body">

</div>


<script src="https://unpkg.com/supercluster@8.0.0/dist/supercluster.min.js"></script>

<script>
    class ClusterLayers {
        constructor(map, source_name) {
            this.map = map;
            this.source = source_name;
            this.circle_color = [
                'step',
                ['get', 'point_count'],
            ];
            this.circle_radius = [
                'step',
                ['get', 'point_count'],
            ];
            this.stepadded = false
            this.finaladded = false
            this.unclustered = ['#11b4da', 4, 1, '#fff']

        }
        addStep(count, radius, color) {
            if (!this.finaladded) {
                this.stepadded = true
                this.circle_color.push(color);
                this.circle_color.push(count);
                this.circle_radius.push(radius);
                this.circle_radius.push(count);
                this.stepadded = true;
            }
            else {
                console.log("Good lad don't add a step after setting the finals")
            }
        }
        setFinal(radius, color) {
            if (this.stepadded) {
                this.circle_color.push(color);
                this.circle_radius.push(radius);
                this.finaladded = true;
            }
            else {
                console.log("Good lad don't add the finals before at least one step")
            }
        }
        SetUnclustered(color, radius, stroke_width, stroke_color) {
            this.unclustered = [color, radius, stroke_width, stroke_color]
        }

        apply() {
            if (this.stepadded && this.finaladded) {
                this.map.addLayer({
                    id: 'clusters',
                    type: 'circle',
                    source: this.source,
                    filter: ['has', 'point_count'],
                    paint: {
                        'circle-color': this.circle_color,
                        'circle-radius': this.circle_radius
                    }
                });

                this.map.addLayer({
                    id: 'cluster-count',
                    type: 'symbol',
                    source: this.source,
                    filter: ['has', 'point_count'],
                    layout: {
                        'text-field': ['get', 'point_count_abbreviated'],
                        'text-font': ['DIN Offc Pro Medium', 'Arial Unicode MS Bold'],
                        'text-size': 12
                    }
                });

                this.map.addLayer({
                    id: 'unclustered-point',
                    type: 'circle',
                    source: this.source,
                    filter: ['!', ['has', 'point_count']],
                    paint: {
                        'circle-color': this.unclustered[0],
                        'circle-radius': this.unclustered[1],
                        'circle-stroke-width': this.unclustered[2],
                        'circle-stroke-color': this.unclustered[3]
                    }
                });
            }
            else {
                console.log("Good lad don't apply before adding a step and the finals")
            }
        }

    }
    class MapCard {
        static token = "";
        static declared = false;
        static setToken(token) { MapCard.token = token; }

        constructor(title, description, cards_container_id, map) {
            // To run one time :
            if (!MapCard.declared) {
                MapCard.declared = true;
                mapboxgl.accessToken = MapCard.token;// set token
                // Arabic Plugin
                mapboxgl.setRTLTextPlugin(
                    'https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-rtl-text/v0.2.3/mapbox-gl-rtl-text.js',
                    null,
                    true
                );

            }
            this.title = title;//card title
            this.description = description;//card Discription
            this.cards_container_id = cards_container_id;// container id
            this.map = map;// the map object
            this.map_container = map.container;// id of the map...
            this.cache = []
            this.cache_max_zoom = 0;
            this.cache_number = 0;
            this.cache_loaded = 0;
            this.url_additional_parameters = ""
            this.steps_with_time = []

        }
        // Print the card in the container div :
        printCard() {// Use insertAdjacentHtml instead of innerHtml (to just add the additional html without removing and re-puting the existing ones)
            document.getElementById(this.cards_container_id).insertAdjacentHTML('beforeend', `
        <div class="card w-100" style="">
            <div id='${this.map.container}' class="w-100" style=' height: 300px;' ></div>
            <div class="card-body">
                <div id='${this.map.container}drawer' ></div>
                <div id='${this.map.container}drawerdownload' ></div>
                <div id='${this.map.container}loader' ></div>
                <div id='${this.map.container}time' ></div>
                <div id='${this.map.container}selector' ></div>
                <h5 class="card-title">${this.title}</h5>
                <p class="card-text">${this.description}</p>
                <div id = '${this.map.container}Load'></div>
            </div>
        </div>`)
        }
        // Adding Changing The Base Map feature
        addStyleSelector() {
            document.getElementById(this.map_container + 'selector').innerHTML = `
        <select class="form-select  mb-3" id='${this.map_container}Select' aria-label="Slect Layer">
            <option value="dark-v11" selected>Dark</option>
            <option value="light-v11" >Light</option>
            <option value="streets-v12" >Streets</option>
            <option value="outdoors-v12" >Outdoors</option>
            <option value="satellite-streets-v12" >Satellite</option>
        </select>
        `;
            var select = document.getElementById(this.map_container + "Select")
            select.onchange = () => { this.map.setStyle('mapbox://styles/mapbox/' + select.value); };
        }
        loadMap() { this.map = new mapboxgl.Map(this.map); }
        getMap() { return this.map; }
        // this source url will be used in fetching the data
        setSourceUrl(url) { this.source_url = url; }
        setSourceUrlParam(param) { this.url_additional_parameters = param; }
        fetchCentroids(bounding = true, zoom_threshold = 10) {
            if (this.map.getZoom() >= zoom_threshold) {
                if (bounding) {
                    var bounds = this.map.getBounds();
                    var ne = bounds.getNorthEast();
                    var sw = bounds.getSouthWest();
                    var url_to_fetch = this.source_url + '&bbox=' + sw.lat + ',' + sw.lng + ',' + ne.lat + ',' + ne.lng
                }
                else {
                    url_to_fetch = this.source_url;
                }
                fetch(url_to_fetch)
                    .then(response => response.json())
                    .then(data => {
                        this.centroids.forEach(marker => {
                            marker.remove();
                        });
                        data.features.forEach(feature => {
                            var coordinates = feature.geometry.coordinates;
                            // Add a symbol to represent the centroid
                            var marker = new mapboxgl.Marker({
                                color: "#FFFFFF",
                                scale: 0.2,
                            })
                                .setLngLat(coordinates)
                                .addTo(this.map);
                            this.centroids.push(marker);
                        });
                    })
                    .catch(error => {
                        console.error('Error fetching centroids from GeoServer:', error);
                    });
            }

        }
        clientFetcher(bounding = true, zoom_threshold = 10) { this.centroids = []; this.map.on('moveend', () => { this.fetchCentroids(bounding = bounding, zoom_threshold = zoom_threshold); }); }
        // set caches from low zoom level to highest 
        setCache(zoom_and_url) {//[zoom,cache_url]
            if (this.cache_loaded != this.cache_number) {
                document.getElementById(this.map_container + 'loader').innerHTML = `
                <div class="w-100 text-center p-3">
                    <button class="btn btn-primary" type="button" disabled>
                <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
                Loading data...
                </button>
                </div>
                `
            }
            if (zoom_and_url[0] > this.cache_max_zoom) {
                var cache_data = false
                // fetching cache
                fetch(zoom_and_url[1])
                    .then(response => response.json())
                    .then(data => {
                        this.cache_loaded++;
                        cache_data = data
                        this.cache.push([zoom_and_url[0], cache_data])
                        console.log("loading Cache")
                        this.cache.sort((a, b) => a[0] - b[0]); // resorting the array in case some cache loaded up before the other ...
                        if (this.cache_loaded == this.cache_number) {
                            document.getElementById(this.map_container + 'loader').innerHTML = ''
                        }
                    })
                    .catch(error => {
                        console.error('Error fetching centroids from GeoServer:', error);
                    });
                this.cache_max_zoom = zoom_and_url[0]
                this.cache_number++;
            } else {
                console.log("good lad, set the caches from lower zoom level to the highest ")
            }
        }
        addTimeStep(title, url_parameter) {
            this.steps_with_time.push([title, url_parameter])
        }
        addTimeFilter() {
            if (this.steps_with_time.length > 0) {
                document.getElementById(this.map_container + 'time').innerHTML = `
                <div class="w-100">
                    <label id="${this.map_container}timelabel"></label>
                    <input id="${this.map_container}slider" type="range" min="0" max="${this.steps_with_time.length-1}" step="1" value="0">
                </div>
                `
                document.getElementById(this.map_container + 'slider').addEventListener('input', (e) => {
                    this.url_additional_parameters= this.steps_with_time[e.target.value][1]
                    document.getElementById(this.map_container + 'timelabel').innerHTML=this.steps_with_time[e.target.value][0]
                    this.fetchClusters();
                });
                this.url_additional_parameters= this.steps_with_time[0][1]
                document.getElementById(this.map_container + 'timelabel').innerHTML=this.steps_with_time[0][0]
                this.fetchClusters();

            } else {
                console.log("Please add Time Step First")
            }
        }
        serverCluster(first = true) {

            var map = this.map
            this.map.on('load', function () {
                map.addSource('clusters', {
                    type: 'geojson',
                    data: {
                        "type": "Feature",
                        "properties": {
                            "name": "My Point",
                            "description": "This is a point"
                        },
                        "geometry": {
                            "type": "Point",
                            "coordinates": [0, 0]
                        }
                    }

                });

                var cluster_layers = new ClusterLayers(map, 'clusters');
                cluster_layers.addStep(100, 20, "#e51e1e")
                cluster_layers.addStep(750, 30, "#ffffff")
                cluster_layers.setFinal(40, "#ffa657")
                cluster_layers.SetUnclustered("#e9bf48", 5, 1, "#69c0ff")
                cluster_layers.apply()

            });


            if (first) {

                this.map.on('moveend', () => {
                    if (this.cache.length > 0) {// make sure there is some cache
                        this.SmartFetchClusters();
                    } else {
                        this.fetchClusters();

                    }
                });


            } else {
                // on changing base map style the source is cleared so we need to reset it 
                this.map.addSource('clusters', {
                    type: 'geojson',
                    data: {
                        "type": "Feature",
                        "properties": {
                            "name": "My Point",
                            "description": "This is a point"
                        },
                        "geometry": {
                            "type": "Point",
                            "coordinates": [0, 0]
                        }
                    }

                });

                var cluster_layers = new ClusterLayers(this.map, 'clusters');
                cluster_layers.addStep(100, 20, "#e51e1e")
                cluster_layers.addStep(750, 30, "#ffffff")
                cluster_layers.setFinal(40, "#ffa657")
                cluster_layers.SetUnclustered("#e9bf48", 5, 1, "#69c0ff")
                cluster_layers.apply()
            }
            this.fetchClusters();

        }
        fetchClusters() {
            fetch(`${this.source_url}?zoom=${this.map.getZoom()}&bbox=${this.map.getBounds().toArray().join(',')}${this.url_additional_parameters}`)
                .then(response => response.json())
                .then(data => {
                    this.updateClusters(data)
                })
                .catch(error => {
                    console.error('Error fetching centroids from GeoServer:', error);
                });
        };
        SmartFetchClusters() {//[zoom threshold, this.cache]
            if (this.map.getZoom() < this.cache_max_zoom) {
                console.log("smartCluster")
                for (let i = 0; i < this.cache.length; i++) {
                    if (this.cache[i][0] > this.map.getZoom()) {

                        this.updateClusters(this.cache[i][1])
                        break;
                    }
                }
            } else {
                this.fetchClusters()

            }
        }
        updateClusters(data) {

            // Putting Data in GeoJson Format
            var geojsonData = {
                type: "FeatureCollection",
                features: data
            };
            JSON.stringify(geojsonData);
            // Set Data
            if (!(this.map.getSource('clusters'))) {
                this.serverCluster(false)

            }
            this.map.getSource('clusters').setData(geojsonData);

            // Update the cluster layer
            this.map.setLayoutProperty('clusters', 'visibility', 'visible');

            // Update the cluster count labels layer
            this.map.setLayoutProperty('cluster-count', 'visibility', 'visible');
        }
        clientCluster(buttonLoaderCase = false) {

            this.map.addSource('clusters', {
                type: 'geojson',
                data: this.source_url,
                cluster: true,
                clusterMaxZoom: 14, // Max zoom to cluster points on
                clusterRadius: 50 // Radius of each cluster when clustering points (defaults to 50)
            });

            var cluster_layers = new ClusterLayers(map, 'clusters');
            cluster_layers.addStep(100, 20, "#e51e1e")
            cluster_layers.addStep(750, 30, "#ffffff")
            cluster_layers.setFinal(40, "#ffa657")
            cluster_layers.SetUnclustered("#e9bf48", 5, 1, "#69c0ff")
            cluster_layers.apply()
            if (buttonLoaderCase) {
                // Once the map finishes loading
                this.map.on('idle', () => {
                    // Set button text to "loaded completely"
                    const button = document.getElementById(this.map_container + 'Load').querySelector('button');
                    button.className = 'btn w-100 btn-success p-2';
                    button.textContent = 'Loaded completely';
                    button.disabled = true;
                });
            }
        }
        clusterLoadButton() {
            // Create a button element
            const button = document.createElement('button');
            button.textContent = 'Load Cluster Map';
            button.addEventListener('click', () => {
                button.disabled = true;
                button.textContent = "Loading ...";
                this.clientCluster(this.source_url, true); // Call clientCluster function when button is clicked
            });
            button.className = "btn w-100 btn-info text-white p-2"

            document.getElementById(this.map_container + 'Load').appendChild(button);

        }
        setMaxZoom(zoom) { this.map.setMaxZoom(zoom); }
        setMinZoom(zoom) { this.map.setMinZoom(zoom); }
        setBounds(bounds) { this.map.setMaxBounds(bounds); }
        addGeoLocator() {
            this.map.addControl(
                new mapboxgl.GeolocateControl({
                    positionOptions: {
                        enableHighAccuracy: true
                    },
                    trackUserLocation: true,
                })
            );
        }
        addNavigation() { this.map.addControl(new mapboxgl.NavigationControl()); }
        addScale() { this.map.addControl(new mapboxgl.ScaleControl()); }
        addFullScreen() { this.map.addControl(new mapboxgl.FullscreenControl()); }
        // Drawing 
        addDrawing(polygon = true, point = false, line_string = false) {
            this.draw = new MapboxDraw({
                displayControlsDefault: false,
                controls: {
                    polygon: polygon,
                    point: point,
                    line_string: line_string,
                    trash: true
                }
            });
            this.map.addControl(this.draw)
        }
        ShowDrawingArea() {
            if (this.draw) {
                this.map.on('draw.selectionchange', (e) => {
                    const selected = e.features[0];
                    if (selected && selected.geometry.type === 'Polygon') {
                        const area = this.PolygonArea(selected);
                        console.log(`Selected area: ${area} square meters`);
                        document.getElementById(this.map_container + 'drawer').innerHTML = `<div class= "text-center w-100 my-2 ">The Selected Polygon Area is <span class="text-info" >${area} square meters</span></div>`
                    }
                });
            } else {
                console.log("addDrawing First")
            }
        }
        DownloadDrawingArea() {
            if (this.draw) {
                this.map.on('draw.selectionchange', (e) => {
                    const selected = e.features[0];
                    if (selected && selected.geometry.type === 'Polygon') {
                        const coordinates = selected.geometry.coordinates[0];
                        const bounds = coordinates.reduce((bounds, coord) => {
                            return bounds.extend(coord);
                        }, new mapboxgl.LngLatBounds(coordinates[0], coordinates[0]));

                        const southWest = bounds.getSouthWest();
                        const northEast = bounds.getNorthEast();
                        const center = bounds.getCenter();

                        const mapDim = {
                            width: window.innerWidth,
                            height: window.innerHeight
                        };

                        const zoom = this.calculateZoom(bounds, mapDim);
                        const url = `https://api.mapbox.com/styles/v1/mapbox/satellite-streets-v12/static/${center.lng},${center.lat},${zoom}/1200x1200?access_token=${mapboxgl.accessToken}`;
                        document.getElementById(this.map_container + 'drawerdownload').innerHTML = `<div class= "text-center w-100 my-2 "><a href="${url}" target='_blank' class="text-decoration-none btn btn-primary">Open Up the </a></div>`
                    }
                });

            } else {
                console.log("addDrawing First")
            }
        }
        calculateZoom(bounds, mapDim) {
            const WORLD_DIM = { height: 256, width: 256 };
            const ZOOM_MAX = 22;

            function latRad(lat) {
                const sin = Math.sin(lat * Math.PI / 180);
                const radX2 = Math.log((1 + sin) / (1 - sin)) / 2;
                return Math.max(Math.min(radX2, Math.PI), -Math.PI) / 2;
            }

            function zoom(mapPx, worldPx, fraction) {
                return Math.floor(Math.log(mapPx / worldPx / fraction) / Math.LN2);
            }

            const latFraction = (latRad(bounds.getNorth()) - latRad(bounds.getSouth())) / Math.PI;

            const lngDiff = bounds.getEast() - bounds.getWest();
            const lngFraction = ((lngDiff < 0 ? (lngDiff + 360) : lngDiff) / 360);

            const latZoom = zoom(mapDim.height, WORLD_DIM.height, latFraction);
            const lngZoom = zoom(mapDim.width, WORLD_DIM.width, lngFraction);

            return Math.min(latZoom, lngZoom, ZOOM_MAX);
        }
        PolygonArea(feature) {
            if (feature.geometry.type === 'Polygon') {
                return turf.area(feature);
            }
            return 0;
        }


    }


    MapCard.setToken("pk.eyJ1IjoibWhkMTIzbXN3aSIsImEiOiJjamp0azg5OHAyaGIxM3Fvbjc0b3pvZ2VpIn0.vmB_VWu_ewHeNBtoEtdt7Q");
    card = new MapCard(" The Lebanese Urban Map", "The first comprehensive Lebanese Urban Map was completely autonomously generated using  Deep Learning Models that were developed and tested at the National Council for Scientific Research (CNRS).", "main_cards_body", {
        container: 'map1',
        style: 'mapbox://styles/mapbox/satellite-streets-v12',
        center: [36, 34],
        zoom: 6.5
    });


    card.printCard();

    card.loadMap();
    card.addFullScreen();
    card.addNavigation()
    card.addScale()
    card.addStyleSelector()
    card.addGeoLocator()

    card.setCache([8, 'https://geoai.cnrs.edu.lb/geoaigeoserver/static/deja_clustered/lebanon_6.json'])
    card.setCache([9, 'https://geoai.cnrs.edu.lb/geoaigeoserver/static/deja_clustered/lebanon_7.json'])
    card.setCache([10, 'https://geoai.cnrs.edu.lb/geoaigeoserver/static/deja_clustered/lebanon_8.json'])
    card.setCache([11, 'https://geoai.cnrs.edu.lb/geoaigeoserver/static/deja_clustered/lebanon_9.json'])
    card.setCache([12, 'https://geoai.cnrs.edu.lb/geoaigeoserver/static/deja_clustered/lebanon_10.json'])
    card.setCache([13, 'https://geoai.cnrs.edu.lb/geoaigeoserver/static/deja_clustered/lebanon_11.json'])
    card.setCache([15, 'https://geoai.cnrs.edu.lb/geoaigeoserver/static/deja_clustered/lebanon_12.json'])
    card.setSourceUrl("https://geoai.cnrs.edu.lb/geoaigeoserver");
    card.serverCluster()

    wheat_card = new MapCard("The Lebanese Wheat Map", "The first Lebanese Wheat Map completely autonomously generated using Deep Learning Models By GeoAI Group", "main_cards_body", {
        container: 'map2',
        style: 'mapbox://styles/mapbox/satellite-streets-v12',
        center: [36, 34],
        zoom: 6.5
    });

    wheat_card.printCard();
    wheat_card.loadMap();
    wheat_card.addFullScreen();
    wheat_card.addNavigation();
    wheat_card.addScale()
    wheat_card.addStyleSelector()
    wheat_card.addGeoLocator()
    wheat_card.setSourceUrl("https://geoai.cnrs.edu.lb/geoaigeoserver/wheat");
    wheat_card.serverCluster();
    wheat_card.addTimeStep("2016","&year=2016")
    wheat_card.addTimeStep("2017","&year=2017")
    wheat_card.addTimeStep("2018","&year=2018")
    wheat_card.addTimeStep("2019","&year=2019")
    wheat_card.addTimeStep("2020","&year=2020")
    wheat_card.addTimeStep("2021","&year=2021")
    wheat_card.addTimeStep("2022","&year=2022")
    wheat_card.addTimeStep("2023","&year=2023")
    wheat_card.addTimeFilter()

    // card.addDrawing()
    // card.ShowDrawingArea()
    // card.DownloadDrawingArea()

</script>
